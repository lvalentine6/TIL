프로세스 관리
------------
* 프로세스의 생성
  * 부모 프로세스(parent process)가 자식 프로세스(children process)를 생성
  * 프로세스 트리 형성
  * 프로세스의 자원은 운영체제로 부터 할당 받음
    * 일반적으로는 자원을 부모 프로세스와 자식 프로세스가 공유하지 않음
    * 특수한 케이스에서는 모든 자원을 공유하거나 일부를 공유할 수 있음
* 부모 프로세스와 자식 프로세스가 공존하는 모델과 자식 프로세스의 종료를 부모 프로세슷가 기다리는 모델이 있음
* os를 통해 자식 프로세스는 부모 프로세스의 공간을 복사 -> 그 공간에 새로운 프로그램을 올림
* 프로세스의 종료
  * 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려주는 경우(exit)
    * 자식 프로세스가 output data를 보냄(via wait)
    * 프로세스의 각종 자원들이 os에게 반납
  * 부모 프로세스가 자식의 수행을 종료시키는 경우(abort)
    * 자식 프로세스가 할당 자원의 한계치를 넘어섬
    * 자식에게 할당된 task가 더 이상 필요하지 않음
    * 부모 프로세스가 종료(exit) 하는 경우
      * os는 부모 프로세스가 종료하는 경우 자식 프로세스를 종료시킴
      * 가장 하위 자식 프로세스부터 부모 프로세스까지 단계적인 종료
  <br/><br/>
* 프로세스와 관련한 시스템 콜
  * fork() 시스템 콜
    * 부모 프로세스를 복제 -> 자식 프로세스는 fork() 이후의 코드를 실행
    * 부모 프로세스는 fork()의 결과값을 양수로 가지고 자식 프로세스는 결과값을 0으로 가져 둘을 구별한다.
  * exec() 시스템 콜
    * exec()은 입력값을 받아 새로운 데이터를 덮어씌워 main 시작부터 끝까지 실행
    * exec() 이후 코드는 실행되지 않고 되돌아 올수 없음
  * wait() 시스템 콜
    * 프로세스 A가 wait() 시스템 콜을 호출하면 커널은 자식 프로세스가 종료될 때까지 프로세스 A를 sleep 시킨다.(blocked 상태)
    * 자식 프로세스가 종료되면 커널은 프로세스 A를 깨운다.(ready 상태)
  * exit() 시스템 콜
    * 자발적 종료
      * 마지막 statement 수행 후 exit() 시스템 콜을 통해 종료됨
      * 프로그램에 명시적으로 넣어주지 않아도 main 함수가 return 되는 위치에 컴파일러가 자동으로 추가
    * 비자발적 종료
      * 부모 프로세스가 자식 프로세스를 강제 종료시킴
      * 키보드로 kill, break를 입력한 경우
      * 부모 프로세스가 종료하는 겅우
  <br/><br/>
* 프로세스 간 협력
  * 독립적 프로세스 
    * 프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함
  * 협력 프로세스
    * 프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음
  * 프로세스 간 협력 메커니즘(IPC : Interprocess Communication)
    * 메시지를 전달하는 방법
      * message passing : 커널을 통해 메시지 전달
        * direct communication : 통신하려는 프로세스의 이름을 명시적으로 표시
        * indirect communication : mailbox(or port)을 통해 메시지를 간접 전달
    * 주소 공간을 공유하는 방법
      * shared memory : 서로 다른 프로세스 간에도 일부 주소 공간을 공유하는 shared memory 메커니즘 존재
    * 스레드는 하나의 프로세스이므로 프로세스 간 협력이라 보기 어렵지만 동일한 프로세스를 구성하는 스레드간에는 주소 공간을 공유하므로 협력이 가능
  <br/><br/>
* CPU 스케줄링
  * 프로그램 종류에 따라 cpu burst -> IO burst 반복되는 주기가 다름
    * cpu를 오래쓰는 작업을 cpu bound job이라 함 (계산위주)
    * IO가 자주 있는 작업을 IO bound job이라 함
  * 여러 종류의 job이 섞여있기 때문에 cpu 스케줄링이 필요함
  * cpu와 IO 장치 등 시스템 자원을 효율적으로 사용하는데 목적이 있음
  * cpu scheduler (os에 내장되어 있는 코드 부분)
    * ready 상태의 프로세스 중에서 이번에 cpu를 줄 프로세스를 고른다.
  * dispatcher (os에 내장되어 있는 코드 부분)
    * cpu 제어권을 cpu scheduler에 의해 선택된 프로세스에게 넘김
    * 이 과정을 context switch(문맥교환)이라 한다.
  * preemptive : 강제로 cpu 제어권을 뺏는것
  * nonpreemptive : 자진해서 cpu 제어권을 반납
  
