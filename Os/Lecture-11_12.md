Disk Management and Scheduling
------------------------------

* 디스크 구조
  * 디스크의 최소 단위는 섹터이다.
  * 디스크의 외부에서는 디스크의 최소 단위를 논리적 블럭으로 본다.
    * 논리적 블럭
      * 주소를 가진 1차원의 배열처럼 취급
      * 정보를 전송하는 최소 단위
    * 섹터
      * 논리적 블록이 물리적인 디스크에 매핑된 위치
      * 섹터 0번은 최외곽 실린더의 첫 트랙에 있는 첫 번째 섹터이다.
* 디스크 관리
  * 물리적 포맷 (로우 레벨 포맷)
    * 디스크를 컨트롤러가 읽고 쓸 수 있도록 섹터들로 나누는 과정
    * 각 섹터는 header + 실제 data + trailer로 구성된다.
    * header와 trailer는 섹터 번호, Error-Correctiong Code 등의 정보가 저장되며 controller가 직접 접근 및 운영한다.
  * 파티셔닝
    * 디스크를 하나 이상의 실린더 그룹으로 나누는 과정
    * 운영체제는 이것을 독립적 disk로 취급
  * 논리적 포맷
    * 파일 시스템을 만드는 것
    * FAT, Inode 등의 구조 포함
  * 부팅
    * ROM에 있는 small bootstrap loader가 실행
    * 섹터 0번을 로드하여 실행
    * 섹터 0번은 부트로더가 위치함
    * 운영체제의 커널을 메모리에 올려 실행
* 디스크 스케줄링
  * Access time의 구성
    * Seek time
      * 헤드를 해당 실린더로 움직이는데 걸리는 시간
    * Rotational latency
      * 헤드가 원하는 섹터에 도달하기까지 걸리는 회전지연시간
    * Transfer time
      * 실제 데이터의 전송 시간
  * Disk bandwidth
    * 단위 시간당 전송된 바이트의 수
  * 디스크 스케줄링의 목표
    * seek time을 최소화 하는것
* 디스크 스케줄링 알고리즘
  * 엘리베이터 처리 알고리즘과 비슷함
  * 파일 할당 방벙에 따라 디스크 요청이 영향을 받음
  * 디스크 스케줄링 알고리즘은 필요한 경우 다른 알고리즘으로 쉽게 교체할 수 있도록 OS와 별도의 모듈로 작성되는것이 좋음
  * FCFS(First come first service)
    * 큐에 먼저 들어온 순서대로 처리
  * SSTF(Shortest seek time first)
    * 큐에 있는 요청중 현재 헤드 위치에서 가장 가까운 요청을 처리
    * starvation이 발생할 수 있음
  * SCAN
    * 헤드가 디스크의 한쪽 끝에서 다른쪽 끝으로 이동하여 가는 길목에 있는 모든 요청을 처리
    * 다른 한쪽 끝에 도달하면 역방향으로 이동하여 오는 길못에 있는 모든 요청 처리
    * 실린더 위치에 따라 대기 시간이 다르다.
  * C-SCAN
    * 헤드가 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리
    * 다른쪽 끝에 도달했으면 요청을 처리하지 않고 곧바로 출발점으로 다시 이동
    * SCAN보다 균일한 대기 시간을 가짐
  * N-SCAN
    * 일단 헤드가 한 방향으로 움직이기 시작하면 그 시점 이후에 도착한 요청은 되돌아 올 때 처리
  * LOOK and C-LOOK
    * SCAN이나 C-SCAN은 헤드가 디스크 끝에서 끝으로 이동
    * LOOK과 C-LOOK은 헤드가 진행중이다가 그 방향에 더 이상 요청이 없으면 헤드의 이동방향을 즉시 반대로 설정하여 이동
    * 디스크 입출력이 많은 시스템에서 효율적임
* Swap-Space 관리
  * 디스크를 사용하는 두 가지 이유
    * 메모리에 저장할 수 없는 영속적인 자료 저장을 위해
    * 프로그램 실행시 Swap space를 위해
  * swap-space
    * 가상 메모리 시스템에서는 디스크를 메모리의 연장 공간으로 사용
    * 파일 시스템 내부에 둘 수도 있으나 별도 파티션 사용이 일반적
      * 공간 효율성보다는 속도 효율성이 우선
      * 일반 파일보다 훨씬 짧은 시간만 존재하고 자주 참조함
      * 따라서 블록의 크기 및 저장 방식이 일반 파일시스템과 다름
* RAID(Redundant Array of Independent Disks)
  * 여러개의 디스크를 묶어서 사용하는 것
  * RAID의 사용 목적
    * 디스크 처리 속도 향상
      * 여러 디스크에 블록의 내용을 분산 저장
      * 병렬적으로 읽어 옴(미러링, 쉐도잉)
    * 신뢰성의 향상
      * 동일 정보를 여러 디스크에 중복 저장
      * 하나의 디스크가 고장일때 다른 디스크에서 읽어옴
      * 단순한 중복 저장이 아니라 일부 디스크에 parity를 저장하여 공간의 효율성을 높일 수 있다.