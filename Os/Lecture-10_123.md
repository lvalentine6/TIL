File System
-------------

* 파일
  * 일반적으로 보조 기억 장치에 저장된다.
  * 운영체제는 다양한 저장 장치를 file이라는 동일한 논리적 단위로 볼 수 있게 한다.
  * 파일의 연산자
    * create, read, write, reposition(lseek), delete, close 등
    * reposition : 위치를 변경 및 저장하는 연산자
    * open : meta data를 메모리에 올리는 연산자
    * 모든 연산자는 시스템 콜이다.
  * 파일의 속성(메타 데이터)
    * 파일을 관리하기 위한 정보
      * 파일 이름, 유형, 저장된 위치, 파일 사이즈
      * 접근권한(읽기, 쓰기, 실행), 시간(생성, 변경, 사용), 소유자
  * 파일 시스템
    * 운영체제에서 파일을 관리하는 부분
    * 파일 및 파일의 메타 데이터, 디렉토리 정보 등을 관리
    * 파일의 저장 방법 결정
    * 파일 보호
  * open() 연산자
    * open("/a/b/c")
      * 디스크에서 파일 c의 메타 데이터를 메모리에 가져오는것이 목적
      * root 디렉토리에서 /를 open 하고 그 안에서 파일 위치 a를 찾는다.
      * 파일 a를 open 하고 read 하여 그 안에서 파일 b의 위치를 찾는다.
      * 파일 b를 open 하고 read 하여 그 안에서 파일 c의 위치를 찾는다.
      * 파일 c를 open 한다.
    * 디렉토리 경로 탐색에 너무 많은 시간이 소요됨으로 open을 read와 write와는 별도로 둔다.
    * 한번 open 파일은 read, write시 디렉토리 탐색이 필요없다.
    * Open file table
      * 현재 open 된 파일의 메타 데이터 보관소이다. 
      * 메타 데이터외에도 추가적인 정보가 있다.
        * open한 프로세의 수
        * file offset : 파일의 어느 위치를 접근중인지 표시
      * 파일 descriptor
        * 프로세스별 Open file table에 대한 위치 정보
    * open()의 동작 과정
      * 디스크에 있던 root의 메타 데이터가 메모리로 올라간다.
      * root의 주소를 찾아가고, root에 존재하는 a의 메타 데이터에 접근한다.
      * a의 메타 데이터를 메모리에 올린다. (Open file table)
      * a의 주소를 찾아가고, a에 존재하는 b의 메타 데이터에 접근한다.
      * b의 메타 데이터를 메모리에 올린다. (Open file table)
      * 프로세스가 open() 시스템 콜의 반환 값을 전달 받는다.
      * b의 메타 데이터가 위치하는 포인터 값 (file descriptor) ⇒ Open file table의 인덱스 값
      * read() 시스템 콜이 발생하면, fd 값을 이용하여 b의 컨텐츠를 읽고, 그 값을 디스크 상의 버퍼 캐시에 저장한다.
      * b의 컨텐츠를 커널 메모리 상의 버퍼 캐시에 저장한다.
      * b의 컨텐츨를 사용자 메모리 상의 버퍼 캐시에 접근한다.
      * file system에서는 LRU, LFU와 같은 알고리즘을 사용한 버퍼 캐싱이 가능하다. -> 시스템콜이 발생하기 때문
* 디렉토리와 논리적 디스크
  * 디렉토리
    * 파일의 메타 데이터 중 일부를 보관하고 있는 일종의 특별한 파일
    * 그 디렉토리에 속한 파일 이름 및 속성
    * 연산자
      * search for file, create a file, delete file
      * list a directory, rename a file, traverse the file system
  * 파티션
    * 하나의 물리적 디스크 안에 여러 파티션을 두는 것이 일반적이다.
    * 여러 개의 물리적인 디스크를 하나의 파티션으로 구성하기도 한다.
    * 물리적 디스크를 파티션으로 구성한 뒤 각각의 파티션에 파일 시스템을 깔거나 스와핑 등 다른 용도로 사용할 수 있다.
* 파일 보호
  * 각 파일에 대해 누구에게 어떤 유형의 접근을 허락할 것인지 정하는 것
  * Access Control Matrix
    * 행은 각 유저를, 열은 각 파일로 하여 행렬을 만들어 read, write, execution을 표시한다.
    * 각 유저와 파일마다 행렬을 추가해야 하기 때문에 자원의 소비가 많다.
  * Grouping
    * 전체 user를 owner, group, public의 세 그룹으로 나눈다.
    * 각 파일에 대해 세 그룹의 접근권한을 3비트씩 표시하여 총 9비트로 표현이 가능하다.
    * UNIX에서 사용하는 방식이다.
  * Password
    * 파일마다 비밀번호를 설정하는 방법
    * 접근 권한 별 패스워드에 대한 암기 문제, 관리 문제가 발생한다.
* 파일 시스템의 마운팅
  * 각각의 논리적인 디스크에는 파일 시스템을 설치하여 루트 파일 시스템 안에 있는 모든 파일은 접근 가능하다.
  * 다른 파티션에 있는 파일 시스템을 접근하고 싶다면 마운팅을 통해 접근이 가능하다. 
* 파일 정보의 접근 방식
  * 시스템이 제공하는 파일 정보의 접근 방식
    * 순차 접근
      * 카세트 테이프를 사용하는 방식처럼 접근한다.
      * 읽거나 쓰면 offset은 자동으로 증가한다.
    * 직접 접근
      * LP 레코드 판과 같이 접근한다.
      * 파일을 구성하는 레코드를 임의의 순서로 접근할 수 있다.
* 디스크에 파일의 데이터 할당하는 방식
  * 파일을 동일한 크기 단위인 sector로 나누어 저장한다. 
    * 연속 할당
      * 하나의 파일이 디스크에 상에 연속해서 저장되는 방식으로 각 블록이 연속된 번호를 부여 받는다.
      * 장점
        * 빠른 입출력
        * 임의 접근이 가능
      * 단점
        * 외부 조각이 발생
        * 파일이 커질때 대처하기 어려움
          * 파일 생성시 어느정도의 크기로 할당할 것인가?
          * grow 정도를 크게 할수록 내부 조각 문제가 발생
    * 연결 할당
      * sector들이 Linked List의 Node가 되는 구조를 가진다.
      * 장점
        * 외부 조각이 생기지 않음
      * 단점
        * 임의 접근이 불가능
        * 하나의 sector가 고장나면 그 뒤에 sector는 접근이 불가능함
        * 포인터를 위한 공간이 필요하므로 공간 효율성이 떨어지게 됨
      * 변형
        * File-allocation (FAT) 시스템
          * 포인터를 별로의 위치에 보관하여 신뢰서 문제와 공간 효율성 문제를 해결
    * 인덱스를 아용한 할당
      * 파일의 sector를 기록한 블록을 하나 생성한다.
      * 장점
        * 외부 조각이 발생하지 않음
        * 임의 접근이 가능
      * 단점
        * 작은 파일의 경우 공간 낭비가 심함
        * 매우 큰 파일의 경우 하나의 인덱스 블록으로 커버할 수 없다.
          * 해결 방안
          * Linked scheme : 인덱스 블록을 여러개 두는것
          * MultiLevel index : 블록의 마지막에 다음 index 블록을 가리키는 값을 설정하여 서로 연결
* 유닉스 파일 시스템의 구조
  * BootBlock
    * 부팅에 필요한 정보를 담고 있는 블록
    * 모든 파일 시스템에 존재하는 블록
  * Super block
    * 파일 시스템에 관한 총체적인 정보를 담고 있는 블록
    * 빈 블록, 사용중인 블록, 각 블록을 구별하는 등 정보를 담고 있다.
  * Inode list
    * 파일 이름을 제외한 파일의 모든 메타 데이터를 따로 저장한다.
    * 파일 하나당 Inode가 하나씩 할당되고 Inode안에 파일의 메타 데이터가 있다.
    * 디렉토리는 파일의 이름과 Inode 번호를 담고 있다.
    * direct blocks는 파일의 인덱스를 저장하는 블록이며 파일의 크기가 크지 않다면 이 블록을 이용하여 파일에 접근한다.
    * direct blocks에 담기 어려운 대용량 파일은 single indirect를 통해서 하나의 level 두어 저장하고 더 커질수록 double indirect -> triple
  * Data block
    * 파일의 실제 내용을 보관하는 블록
* FAT 파일 시스템
  * FAT 파일 시스템은 윈도우즈 계열에서 주로 사용됨
  * 파일의 메타 데이터의 일부를 FAT에 저장하고 나머지 정보는 디렉토리가 가지고 있음
  * FAT는 중요한 정보임으로 복제본을 만들어 관리해야 한다.
* 빈공간 관리
  * sector가 할당되고 남은 hole을 관리하는 방법
  * Linked List
    * 모든 free 블록을 연결하는 방식
    * 공간의 낭비가 없다라는 장점
    * 연속적인 가용 공간을 찾기 어렵다는 단점
  * Grouping
    * Linked List의 변형
    * 하나의 free 블록에 나머지 free 블록에 대한 위치 정보를 저장하는 방식
    * 첫 번째 free 블록이 n개의 포인터를 가짐
  * Counting
    * 프로그램이 종종 여러 개의 연속적인 블록을 할당하고 반납한다는 것에 착안
  * BitMap or BitVector
    * 0이라면 비어 있는 값이고 1이면 sector가 저장된 공간이다.
    * 연속된 n개의 free 블록을 찾기 효과적이지만 0 또는 1을 저장할 공간이 필요함
* 디렉토리 구현
  * 선형 리스트
    * <file name, file의 메타 데이터>의 리스트 
    * 구현이 간단하다. 
    * 디렉토리 내에 파일이 있는지 찾기 위해서는 선형 탐색이 필요하다. (O(N))
  * 해시 테이블 
    * 선형 리스트 + 해싱 
    * 해시 테이블은 file name을 이 파일의 선형 리스트의 위치로 바꾸어 준다. 
    * 탐색 시간이 O(1)이다. 
    * 해시 충돌이 발생할 수 있다.
  * 파일의 메타 데이터의 보관 위치 
    * 디렉토리 내에 직접 보관 
    * 디렉토리에는 포인터를 두고 다른 곳에 보관 
      * Inode, FAT 등 
  * Long file name의 지원
    * <file name, file의 메타 데이터>의 리스트에서 각 엔트리는 일반적으로 고정 크기이다. 
    * 하지만 file name이 고정 크기의 엔트리 길이보다 길어지는 경우 엔트리의 마지막 부분에 file name의 뒷 부분이 위치한 곳의 포인터를 둔다. 
    * file 이름의 나머지 부분은 동일한 directory file의 일부에 존재한다.'
* VFS와 NFS
  * Virtual File System (VFS)
    * 서로 다른 다양한 파일 시스템에 대해 동일한 시스템 콜 인터페이스(API)를 통해 접근할 수 있게 해 주는 OS의 레이어 
  * Network File System (NFS)
    * 분산 시스템에서는 네트워크를 통해 파일이 공유될 수 있다.
    * NFS는 분산 환경에서 대표적인 파일 공유 방법이다.
  * 어떤 파일 시스템을 쓰든 상관 없이 VFS 인터페이스를 사용한다.
  * 분산 시스템에서는 네트워크를 통해 파일을 공유하기 위해 NFS 클라이언트와 NFS 서버가 이용된다.
* 페이지 캐시와 버퍼 캐시
  * 페이지 캐시
    * 가상 메모리의 페이징 시스템에서 사용하는 페이지 프레임을 캐싱의 관점에서 설명하는 용어
    * Memory-Mapped I/O를 쓰는경우 파일의 I/O에서도 페이지 캐시를 사용한다.
  * Memory Mapped I/O
    * 파일의 일부를 가상 메모리에 매핑한다.
    * 매핑한 영역에 대한 메모리 접근 연산은 파일의 입출력을 수행하게 한다.
    * Memory Mapped I/O의 수행
      * 프로세스가 
  * 버퍼 캐시
    * 파일 시스템을 통한 I/O 연산은 메모리의 특정 역역인 버퍼 캐시를 사용한다.
    * 한번 읽어온 블록에 대해서 재요청이 있다면 버퍼 캐시에서 즉시 전달한다.
    * 모든 프로세스가 공용으로 사용한다.
    * 교체 알고리즘이 필요하다.(LRU, LFU)
  * 통합 버퍼 캐시
    * 최근의 OS에서는 기존의 버퍼 캐시가 페이지 캐시에 통합되었다.
* 프로그램의 실행
  * 프로그램이 실행되면 실행 파일이 프로세스가 되며 프로세스만의 독자적인 메모리 공간이 만들어진다.
  * 이 공간은 코드, 데이터, 스택으로 구분되며 당장 사용될 부분은 물리적 메모리에 올라가고 나머지 부분은 스왑 영역에 내려간다.
  * 코드 부분은 이미 파일 시스템에 있기 때문에 스왑 영역에 내리지 않고 사용되지 않으면 물리적 메모리에서 지운다.
  * 코드 부분이 다시 필요하다면 파일 시스템에서 다시 가져온다.
* Memory Mapped I/O의 수행
  * 프로세스가 일반 데이터 파일을 I/O 하고 싶을수 있다.
  * 이떄 mmap()를 호출하면 Memory Mapped 방식으로 파일을 I/O 할 수 있다.
  * mmap()는 시스템 콜이므로 운영체제에 CPU 제어권이 넘어간다.
  * 운영 체제는 데이터 파일의 일부를 프로세스 주소 공간에 매핑한다.
  * 만약 데이터 파일이 매핑된 영역을 접근했을 때 물리적 메모리에 데이터 파일이 올라와 있지 않다면 페이지 부재가 발생한다.
  * 물리적 메모리에 데이터 파일이 매핑된 영역에 있다면 시스템 콜 없이 I/O를 수행할 수 있다.
  * 물리적 메모리에 올라간 데이터 파일과 매핑된 페이지 프레임을 쫒아내야 할 경우 수정된 파일을 파일 시스템에 적용하고 물리적 메모리에서 지운다.
  * 페이지 프레임은 모든 프로세스가 공유하여 사용한다.
* read() 수행
  * 프로세스가 일반 데이터 파일을 I/O 하는 방법으로 read() 시스템 콜을 호출할 수도 있다.
  * read() 시스템 콜을 호출하면 메모리에 버퍼 캐시를 확인해야 하는데 통합 버퍼 캐시 환경에서는 페이지 캐시가 버퍼 캐시 역할을 동시에 수행한다.
  * 그래서 Memory Mapped I/O로 올라간 페이지 캐시를 버퍼 캐시로 사용할 수 있다.
  * 운영 제제는 버퍼 캐시에 있던 내용을 복사하여 프로세스의 주소 공간에 할당한다.
* Memory Mapped I/O와 read() 차이
  * Memory Mapped I/O
    * 가상 메모리에 올라 온 영역이 곧 파일임으로 시스템 콜 없이 I/O 작업을 할 수 있다.
    * 페이지 캐새에 있는 내용을 복사할 필요가 없다.
    * 여러 프로세스가 mmap() 를 사용하여 같은 영역을 공유한다면 일관성이 깨질 우려가 있다.
  * read()
    * 매번 운영체제의 도움을 받는다.
    * 페이지 캐시에 있는 내용을 복사해야 한다.
    * 여러 프로세스가 read()를 사용해도 일관성 문제가 발생하지 않는다.