객체지향 프로그래밍 2
---------------
* 상속 : 기존의 클래스를 재사용하여 새로운 클래스를 작성하는것
  * 자손 클래스는 조상 클래스의 모든 맴버를 상속받는다.
  * 자손 클래스의 맴버 개수는 조상 클래스의 맴버와 같거나 많다.
  * 생성자는 상속되지 않는다.
  * 자바는 단일 상속만을 허용한다. 클래스간의 관계가 명확해지고 신뢰할 수 있게 만드는 장점이 있다.
  * 자바의 모든 클래스는 object 클래스를 상속받는다.
  <br/><br/>
  * 포함관계 : 한 클래스의 맴버변수로 다른 클래스 타입의 참조변수를 생성하는것
    * 상속과 포함
      * 은 ~이다. -> 상속 관계
      * 은 ~을 가지고 있다 -> 포함 관계
        * 원은 점이다. (X)
        * 원은 점을 가지고 있다. (O)
  <br/><br/>
  * 오버라이딩 : 조상 클래스로부터 상속받은 메서드를 재정의 하는것
    * 오버라이딩의 조건
      * 메서드의 선언부(메서드 이름, 매개변수, 반환타입)은 조상 메서드와 일치해야 한다.
      * 접근제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
      * 조상 클래스의 메서드보다 많은 수의 예외를 선언 할 수 없다.
  <br/><br/>
  * 오버로딩 vs 오버라이딩
    * 오버로딩 : 기존에 없던 새로운 메서드를 정의 하는것
    * 오버라이딩 : 상속받은 기존의 메서드를 재정의 하는것
  * 참조변수 super : 상속받은 맴버와 자신의 맴버의 이름이 같을때 자신 -> this , 상속 -> super
  * 조상의 생성자 super() : this()는 같은 클래스의 다른 생성자 호출, super()는 조상의 생성자 호출, 조상의 맴버는 조상의 생성자로 초기화하는것이 좋다.
* 제어자 : 클래스, 변수, 메서드의 선언부에 함께 사용되며 부가적인 의미 부여
  * 접근 제어자 (클래스, 메서드, 맴버변수, 생성자에서 사용 가능)
    * 외부로부터 데이터를 보호하기 위해서, 불필요한 부분을 감추기 위하여 사용된다. -> OOP 캡슐화에 해당
    * 맴버변수에 직접 접근하지 않고, 데이터를 읽고 변경하기 위해서 getter, setter 메서드를 사용
      * public : 접근 제한이 없다.
      * protected : 같은 패키지 내에서, 다른 패키지의 자손 클래스에서 접근이 가능
      * (default) : 같은 패키지 내에서만 접근이 가능하다.
      * private : 같은 클래스 내에사만 접근이 가능하다.
  * 그 외 제어자
    * static : 클래스의, 공통적인 (메서드, 맴버변수, 초기화 블럭에서 사용가능)
      * 맴버변수
        * 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
        * 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
        * 클래스가 메모리에 로드될 때 생성된다.
      * 메서드
        * 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
        * static 메서드 안에서는 인스턴스 맴버들을 직접 사용할 수 없다.
    * final : 마지막의, 변경될 수 없는 (클래스, 메서드, 맴버변수, 지역변수에서 사용가능)
      * 클래스 : 변경될 수 없는 클래스. 확장할 수 없는 클래스가 된다. -> 다른 클래스의 조상이 될 수 없음
      * 메서드 : 변경될 수 없는 메서드. final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다.
      * 맴버변수, 지역변수 : 값을 변경할 수 없는 상수가 된다.
    * abstract : 추상의, 미완성의 (클래스, 메서드에서 사용가능)
      * 클래스 : 클래스 내에 추상 메서드가 선언되어 있음을 의미
      * 메서드 : 선언부만 작성하고 구현부는 작성하지 않는 추상 메서드를 의미 -> 인스턴스를 생성할 수 없음
* 다형성 : 여러 가지 형태를 가질 수 있는 능력
  * 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 구현
  * SmartTv s = new SmartTv(); -> SmartTv 타입의 참조변수로 SmartTv 인스턴스 참조
  * Tv t = new smartTv(); -> 조상 타입 참조변수로 자손 타입 인스턴스 참조
    * Tv 타입의 참조변수로는 SmartTv 인스턴스의 모든 맴버를 다 사용할 수 없다.
    * -> 같은 타입의 인스턴스도 참조변수의 타입에 따라 사용할 수 있는 맴버의 개수가 달라진다.
  * 조상 타입의 참조변수로 자손 타입의 인스턴스를 참조할 수 있다.
  * 그러나 자손 타입의 참조변수로 조상 타입의 인스턴스를 참조할 수는 없다.
  * 참조변수의 형변환
    * 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 가능하나, 참조 변수가 가리키는 인스턴스의 자손타입으로 형변환은 불가능하다.
    * 조상 타입에서 자손 타입으로 형변환할 경우 명시적으로 표현해야 한다.
    <br/>
    `FireEngine f = new fireEngine();
     Car c = (Car)f; (생략가능)
     FireEngine f2 = (FireEngine)c (생략불가)
     Ambulance a = (Ambulance)f; (상속관계가 아니므로 형변환 불가)`
  * instanceof 연산자의 값이 true라면 검사한 타입으로 형변환이 가능하다라는 것을 뜻한다.
  * 매개변수의 다형성
    * 조상 클래스를 매개변수로 사용하면 자손 타입의 참조변수를 매개변수로 사용할 수 있다.