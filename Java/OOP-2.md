객체지향 프로그래밍 2
---------------

* 상속 : 기존의 클래스를 재사용하여 새로운 클래스를 작성하는것
    * 자손 클래스는 조상 클래스의 모든 맴버를 상속받는다.
    * 자손 클래스의 맴버 개수는 조상 클래스의 맴버와 같거나 많다.
    * 생성자는 상속되지 않는다.
    * 자바는 단일 상속만을 허용한다. 클래스간의 관계가 명확해지고 신뢰할 수 있게 만드는 장점이 있다.
    * 자바의 모든 클래스는 object 클래스를 상속받는다.
      <br/><br/>
    * 포함관계 : 한 클래스의 맴버변수로 다른 클래스 타입의 참조변수를 생성하는것
        * 상속과 포함
            * 은 ~이다. -> 상속 관계
            * 은 ~을 가지고 있다 -> 포함 관계
                * 원은 점이다. (X)
                * 원은 점을 가지고 있다. (O)
                  <br/><br/>
    * 오버라이딩 : 조상 클래스로부터 상속받은 메서드를 재정의 하는것
        * 오버라이딩의 조건
            * 메서드의 선언부(메서드 이름, 매개변수, 반환타입)은 조상 메서드와 일치해야 한다.
            * 접근제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
            * 조상 클래스의 메서드보다 많은 수의 예외를 선언 할 수 없다.
              <br/><br/>
    * 오버로딩 vs 오버라이딩
        * 오버로딩 : 기존에 없던 새로운 메서드를 정의 하는것
        * 오버라이딩 : 상속받은 기존의 메서드를 재정의 하는것
    * 참조변수 super : 상속받은 맴버와 자신의 맴버의 이름이 같을때 자신 -> this , 상속 -> super
    * 조상의 생성자 super() : this()는 같은 클래스의 다른 생성자 호출, super()는 조상의 생성자 호출, 조상의 맴버는 조상의 생성자로 초기화하는것이 좋다.
* 제어자 : 클래스, 변수, 메서드의 선언부에 함께 사용되며 부가적인 의미 부여
    * 접근 제어자 (클래스, 메서드, 맴버변수, 생성자에서 사용 가능)
        * 외부로부터 데이터를 보호하기 위해서, 불필요한 부분을 감추기 위하여 사용된다. -> OOP 캡슐화에 해당
        * 맴버변수에 직접 접근하지 않고, 데이터를 읽고 변경하기 위해서 getter, setter 메서드를 사용
            * public : 접근 제한이 없다.
            * protected : 같은 패키지 내에서, 다른 패키지의 자손 클래스에서 접근이 가능
            * (default) : 같은 패키지 내에서만 접근이 가능하다.
            * private : 같은 클래스 내에사만 접근이 가능하다.
    * 그 외 제어자
        * static : 클래스의, 공통적인 (메서드, 맴버변수, 초기화 블럭에서 사용가능)
            * 맴버변수
                * 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
                * 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
                * 클래스가 메모리에 로드될 때 생성된다.
            * 메서드
                * 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
                * static 메서드 안에서는 인스턴스 맴버들을 직접 사용할 수 없다.
        * final : 마지막의, 변경될 수 없는 (클래스, 메서드, 맴버변수, 지역변수에서 사용가능)
            * 클래스 : 변경될 수 없는 클래스. 확장할 수 없는 클래스가 된다. -> 다른 클래스의 조상이 될 수 없음
            * 메서드 : 변경될 수 없는 메서드. final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다.
            * 맴버변수, 지역변수 : 값을 변경할 수 없는 상수가 된다.
        * abstract : 추상의, 미완성의 (클래스, 메서드에서 사용가능)
            * 클래스 : 클래스 내에 추상 메서드가 선언되어 있음을 의미
            * 메서드 : 선언부만 작성하고 구현부는 작성하지 않는 추상 메서드를 의미 -> 인스턴스를 생성할 수 없음
* 다형성 : 여러 가지 형태를 가질 수 있는 능력
    * 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 구현
    * SmartTv s = new SmartTv(); -> SmartTv 타입의 참조변수로 SmartTv 인스턴스 참조
    * Tv t = new smartTv(); -> 조상 타입 참조변수로 자손 타입 인스턴스 참조
        * Tv 타입의 참조변수로는 SmartTv 인스턴스의 모든 맴버를 다 사용할 수 없다.
        * -> 같은 타입의 인스턴스도 참조변수의 타입에 따라 사용할 수 있는 맴버의 개수가 달라진다.
    * 조상 타입의 참조변수로 자손 타입의 인스턴스를 참조할 수 있다.
    * 그러나 자손 타입의 참조변수로 조상 타입의 인스턴스를 참조할 수는 없다.
    * 참조변수의 형변환
        * 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 가능하나, 참조 변수가 가리키는 인스턴스의 자손타입으로 형변환은 불가능하다.
        * 조상 타입에서 자손 타입으로 형변환할 경우 명시적으로 표현해야 한다.
          <br/>
      ``` java
      FireEngine f = new fireEngine();
      Car c = (Car)f; (생략가능)
      FireEngine f2 = (FireEngine)c (생략불가)
      Ambulance a = (Ambulance)f; (상속관계가 아니므로 형변환 불가)`
      ```
    * instanceof 연산자의 값이 true라면 검사한 타입으로 형변환이 가능하다라는 것을 뜻한다.
    * 매개변수의 다형성
        * 조상 클래스를 매개변수로 사용하면 자손 타입의 참조변수를 매개변수로 사용할 수 있다.
* 추상 클래스
    * 클래스가 설계도라면 추상 클래스는 미완성 설계도와 같다. 따라서 인스턴스를 생성할 수 없다.
    * 생성자, 맴버변수, 미완성 메서드(추상 메서드)를 포함하고 있다.
    * 상속을 통해 자손 클래스에서 모든 메서드가 구체화 되야 완성할 수 있다.
    * 기존의 클래스의 공통 부분을 뽑아 조상 클래스를 만드는 것
* 인터페이스
    * 일종의 추상 클래스로 기본 설계도와 같다. 추상 클래스보다 추상화가 정도가 높다.
    * 추상 메서드와 상수만을 맴버로 가진다.
    * 모든 맴버변수는 public static final 이여야 하며 이를 생략할 수 있다.
    * static 메서드와 디폴트 메서드를 제외하고(JDK1.8) 메서드는 public abstract 이여야 하며 이를 생략할 수 있다.
    * 디폴트 메서드와 static 메서드
        * JDK 1.8 부터 static 메서드와 default 메서드의 추가를 허용한다.
        * 인터페이스의 변경 가능성을 고려해 default 메서드가 만들어짐
        * default void newMethod(){} 와 같이 선언한다.
        * 디폴트 메서드가 기존의 메서드와 이름이 종복되어 충돌되는 상황 규칙
            * 여러 인터페이스와 디폴트 메서드 간의 충돌
                * 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.
            * 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
                * 조상 클래스의 메서드가 상속되고 디폴트 메서드는 무시된다.
    * 인터페이스는 인터페이스로부터만 상속받을 수 있으며 다중 상속이 가능하다.
    * 인터페이스를 상속받는 클래스는 인터페이스에 정의된 추상 메서드를 모두 구현해야 한다.
    * 만약 일부만을 구현한다면 abstract를 붙여 추상클래스로 선언해야 한다.
    * 인터페이스의 장점
        * 개발시간을 단축시킬수 있다.
            * 메서드를 호출은 내용에 관계없이 선언부만 알면 되기 떄문에 동시에 개발을 진행할 수 있다.
        * 표준화가 가능하다.
            * 기본 틀을 인터페이스로 작성한 후 구현하게 되면 일관된 개발이 가능하다.
        * 서로 관계없는 클래스에게 관계를 맺어줄 수 있다.
            * 서로 아무런 관계가 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하게 한다면 관계가 생김
        * 독립적인 프로그래밍이 가능하다.
            * 인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있어 한 클래스의 변경이 다른 클래스에 영향을 미치지 않는다.

```
  // 상속과 구현을 동시에 하는것도 가능
  class Fighter extend Unit implements Fightable {
  public void move(int x, int y) {}
  public void attack(Unit u) {}
  }
```

* 인터페이스를 이용한 다형성

```
// 인터페이스 Fightable을 클래스 Fighter가 구현했을 때 Fightable 타입의 참조변수로 참조하는 것이 가능
Fightable f = (Fightable) new Fighter();
Fightable f = new Fighter();

// 인터페이스는 메서드의 매개변수의 타입으로도 사용될 수 있다.
// 메서드 호출시 해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야 한다.
void attack(Fightable f) {
} 

// 리턴 타입으로 인터페이스를 지정하는것도 가능하다.
// 리턴시 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다. 
Fightable method() {
return new Fighter();
}
```

* 내부 클래스
    * 내부 클래스는 클래스 내에 선언된 클래스이다.
    * 내부 클래스의 장점
        * 내부 클래스에서 외부 클래스의 맴버들을 쉽게 접근할 수 있다.
        * 코드의 복잡성을 줄일 수 있다.(캡슐화)
    * 내부 클래스의 종류와 특징
        * 인스턴스 클래스
            * 외부 클래스의 맴버변수 선언위치에 선언하며, 외부 클래스의 인스턴스 맴버처럼 다루어진다.
            * 주로 외부 클래스의 인스턴스 맴버들과 관련된 작업에 사용될 목적으로 선언된다.
        * 스태틱 클래스
            * 외부 클래스의 맴버변수 선언 위치에 선언하며, 외부 클래스의 static 맴버처럼 다루어진다.
            * 주로 외부 클래스의 static 맴버, static 메서드에서 사용될 목적으로 선언된다.
        * 지역 클래스
            * 외부 클래스의 메서드나 초기화 블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.
        * 익명 클래스
            * 클래스의 선언과 객체의 생성을 동시에 하는 이름 없는 클래스
        * 내부 클래스도 클래스이기 때문에 abstractsl final 같은 제어자와 접근 제어자도 사용이 가능하다.
* 익명 클래스
    * 클래스의 선언과 객체의 생성을 동시에 하기 때문에 한번만 사용될 수 있고 하나의 객체만들 생성할 수 있는 일회용 클래스이다.
    * 하나의 클래스를 상속받거나 하나의 인터페이스만 구현 가능하다.
