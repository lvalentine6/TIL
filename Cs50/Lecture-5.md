5강
---------
* 16진수
  * 16진수를 이용하면 2진수를 간단하게 나타낼 수 있다.
  * 2^4가 16이기 때문에 2진수를 4bit씩 나누어 16진수로 표현한다.
  * 숫자가 16진수라는것을 알려주기 위해 앞에 0x를 붙인다.
  * 123456789ABCDEF 순으로 숫자를 표현한다. ex) 0xF -> 15
* 메모리 주소
  * 변수의 메모리상 주소를 알기 위하여 & 연산자를 사용한다.
  * 메모리 주소에 있는 실제 값을 알기 위해서는 * 연산자를 사용한다.
<br/>
```c
int n = 50;
printf(%p\n, &n);
```
  * CS50을 16진수로 표현해보세요.
  * 50을 하나의 숫자로 볼지 5, 0으로 볼지 문자로 볼지에 따라 표현이 다름
  * 50을 숫자로 본다면 CS50 -> 0100 0011, 0101 0011, 0011 0010 -> 0x435332
  * 50을 문자로 본다면 CS50 -> 0100 0011, 0101 0011, 0011 0101, 0011 0000  -> 0x43533530
* 포인터
  * 다른 변수의 주소나, 값을 출력할 수 있게 한다.
  * *p는 이 변수가 포인터라는 것을 의미 
  * *p에 n의 주소를 저장하고 주소를 출력하거나 p가 가리키는 n의 값을 출력할 수 있다.

```c
#include <stdio.h>

int main(void)   
{
int n = 50;  
int *p = &n;
printf("%p\n", p);
printf("%i\n", *p);
}
```
* 문자열 
  * 문자열은 문자의 배열이다.
  * string s = "EMMA"에서 s는 문자열의 가장 첫번째 문자인 'E'를 가리키는 포인터가 된다.
  * 따라서 char *s == string s이다.
```c
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%s\n", s);
}
```
* 문자열 비교
  * == 을 이용해 문자열을 비교한다면 각 문자열의 첫번째 메모리 주소를 비교하게 된다.
  * 그렇기 때문에 같은 문자열을 입력해도 컴퓨터는 다른 문자열로 판단하게 된다.
  * 각 문자열이 같은지 비교하려면 문자의 값을 하나씩 비교해야 한다.
* 문자열의 복사
  * 문자열을 그냥 복사하게 되면 복사된 문자열도 원본 문자열과 동일한 메모리 주소를 가르키게 되므로 값을 수정하면 원본 문자열도 수정된다.
  * 때문에 malloc 이라는 함수를 이용해 정해진 크기만큼 메모리를 할당하고 값을 복사한다.
  * strlen(s) + 1 할당 -> +1은 널 종단 문자를 포함해야 하기 때문
* 메모리 할당과 해제
  * malloc 함수를 이용하여 메모리를 할당했다면 사용이 끝난 후 free 함수로 메모리를 반환해줘야 한다.
  * 그렇지 않으면 메모리에 저장한 값은 쓰레기 값으로 남게 되어 메모리 누수가 발생한다.
  * 할당받은 메모리 영역을 넘어서 사용하려 하면 버퍼 오버플로우가 발생한다.
  * 자바에서는 가비지 컬랙터가 메모리 할당과 해제를 담당함 -> C보다 편하구나 생각함
* 메모리 교환, 힙, 스택
  * 메모리에는 데이터를 저장하는 구역이 나누어져 있다.
  * 힙 영역에는 malloc으로 할당된 메모리의 데이터가 저장되고 메모리가 많이 할당될수록 아래로 내려간다.
  * 스택 영역에는 프로그램 내에 함수와 관련된 것들이 저장되고 함수가 많이 호출될수록 위로 올라간다.
  * 제한된 메모리 용량 안에서 기존의 값을 침범하는 힙 오버플로우나 스택 오버플로우가 발생한다.
  * 바이너리 코드
  * ㅡㅡㅡㅡㅡㅡㅡ
  * 전역변수
  * ㅡㅡㅡㅡㅡㅡㅡ
  * 힙 영역 ↓
  * 
  * 스텍 영역 ↑
```c
#include <stdio.h>

void swap(int a, int b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(x, y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```
  * 스텍 영역에 x, y가 있고 그 위에 a, b, tmp가 있다.
  * a,b 의 교환은 성공적으로 이루어지지만 a,b는 x,y의 복사본이기 때문에 원본에 영향을 주지 못한다.
  * a,b를 x,y를 가리키는 포인터로 지정하면 x,y 의 값을 교환할 수 있다.
```c
#include <stdio.h>

void swap(int *a, int *b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(&x, &y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```
